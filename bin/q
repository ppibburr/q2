#!/usr/bin/env ruby
$t=Time.now
$: << File.join(File.dirname(__FILE__), "/../lib")
require 'rubygems'
require 'ruby2vala'
require 'ruby_parser'

$h ||= false
$s ||= false
$first = ARGV.index('-f')
if $h then
  puts "usage: #{File.basename $0} [options] [file...]"
  puts "options:"
  puts "-h     : display usage"
  puts "-s     : print the sexp before displaying the translated ruby"

  exit 1
end

$i = ARGV.delete("-i")

$run = ARGV.delete("-r")
$exe = ARGV.index("-e")
ARGV.delete_at $exe if $exe
$c = ARGV.delete_at($exe) if $exe
$run = true if $c
ARGV << "%s" if $exe
$shared = ARGV.delete("--lib")
$shared ||= $gir = ARGV.delete("--gir")
$pkg = []

while i=ARGV.index("--pkg")
  ARGV.delete_at(i)
  $pkg << ARGV.delete_at(i)
end


ARGV.push "-" if ARGV.empty? && !$c

$parser = parser    = RubyParser.new
ruby2ruby =$r2v= Ruby2Ruby.new
$delete = []
$scope = [Scope.new]
$sa = sa={}
$ruby = []
$one=nil
$req = {}
class Sexp
  def mb;@mb;end
  def mb=q;@mb=q;end
end
def r2vala sexp
  $mb=false
  l=$req[sexp.file] = $r2v.process(sexp)
  if $mb
  
    q=$scope[-1].map.map do |k,v|
      (v.to_s! == "var") ? "" : "#{v} #{k};"
    end.join("\n  ").strip
    if t=$scope[0].map["_q_match_data"]
   #   q << "\n_q_match_data #{t};\n"
    end
    $scope.pop if $scope[-2] == $scope[0]
    l.gsub!(/\%__Q_MAIN_DEC__;/,"  "+q)
    l << "\n  return 0;\n}"
  end
end

def output
  $sao.map do|f| "// File: #{f}\n\n"+$req[f] end.join("\n\n\n")
end

def write
  `mkdir -p ./q_generated/#{$prg}`
  $sao.map do|f| 
    out = File.join("./q_generated", $prg, File.basename(f)+".vala")
    STDERR.puts "transpiled: #{out}"
    File.open(out,"w") do |o| o.puts "// File: #{f}\n\n"+$req[f] end
    out
  end
end

def compile f, prg=$prg
  pkg = '' #if !$pkg or $pkg.empty?
  
  unless !$pkg || $pkg.empty?
    pkg << " --pkg "
    pkg << $pkg.join(" --pkg ")
  end
  
  lib=prg
  lib = prg.split("_").map do |q| q.capitalize end.join() if $gir
  l = ""
  l = " --library=#{lib} -H #{prg}.h -X -fPIC -X -shared" if $shared
  l << " --gir #{lib}-0.1.gir" if $gir
  prg = prg+".so" if $shared
  STDERR.puts c="valac#{l} #{f.join(" ")}#{pkg} -o #{prg}"
  system c
end

def run prg=$prg
  c="./#{prg}"
  STDERR.puts c
  system c
end

$sao=[]
ARGV.each do |file|
  if $i

    q = DATA.read % f=File.expand_path(file)
    File.open("./.libq.rb","w") do |o| o.puts q end
    puts c="ruby -r ./.libq.rb #{f}"
    `#{c}` 
    exit
  end

  if file == '-'
    $run=true
    `mkdir -p ./.q_in`
    file = "./.q_in/e.rb" 
    File.open(file,"w") do |f| f.puts $stdin.read end
  end
  
  if file == '%s'
    $run=true
    `mkdir -p ./.q_in`
    file = "./.q_in/e.rb" 
    File.open(file,"w") do |f| f.puts $c end
  end  
  
  $pdir ||= File.dirname(file)
  $prg ||= File.basename(file).split(".")[0]
  $sao << f=f_path(file)

  sexp = q_require file

  p sexp if $s

  $req[file] = $one=ruby2ruby.process(sexp)
  puts output if $first
end

$req = {}

## One pass transpilation, requires more strict typing
# puts $one;exit

File.open("./types.rbm", "w") do |f|
  f.puts Marshal.dump($scope[0])
end

  begin
    $scope = [Marshal.load(open('./types.rbm').read)]
  rescue
    raise "hell"
  end

$SIG=nil
$KLASS=nil
$FE=nil
$return=nil

a=$ruby
$ruby = []
i=-1
#$two = true
sa.each do |f,sexp|
  $ruby << a[i+1]

  $req[sexp.file] = o=ruby2ruby.process(sexp)
  puts out="namespace Q { public double tt = #{Time.now-$t};}\n\n"+output if $two
  
  ## Two pass compilation more inference
  ## return types, full type assignment to vars, argument types from usage, more fields values
  exit if $two
end
$req = {}
File.open("./types.rbm", "w") do |f|
  f.puts Marshal.dump($scope[0])
end

  begin
    $scope = [Marshal.load(open('./types.rbm').read)]
  rescue
    raise "hell"
  end

$SIG=nil
$KLASS=nil
$FE=nil
$return=nil


$ruby = []
i=-1
$sao.each do |f|
  sexp = $sa[f]
  $ruby << a[i+1]
  
  r2vala(sexp)
  
  ##  Three passes: much infer
  ##  return type, full type var assigment, return of type infered from argument, most field values
end

$req["./q.q"] = "namespace Q { public double tt = #{Time.now-$t};}\n\n"
$sao.unshift "./q.q"
puts output if $v

compile write
run if $run && !$shared
def vapi scope
scope.map.map do |k,v|
  if v.is_a?(Scope)
    if v.namespace?
      "namespace #{v.name} {"+
        vapi(v)
      "}"
    elsif v.class?
      "public class #{v.name} {"+
        vapi(v)
      ""
      
    else 
      v.name
    end
  end
end.join("\n")
end

__END__
$: << f=File.expand_path(File.dirname("%s"))
STDERR.puts f
require 'glib2'
class GLib::Object
  alias :q_mm :method_missing
  def method_missing m,*o,&b
    if self.class.signals.index(s=m.to_s.gsub("_",'-'))
      QGSignal.new(self,s)

    else
      q_mm m,*o,&b
    end
  end
  
  class QGSignal
    def initialize ins, s='', &b
      @ins = ins; @s=s
      @b=b
    end
    
    def connect &b
      @ins.signal_connect(@s,&b)
    end
    
    def [] *o,&b
      @b.call *o,&b
    end 
  end
end

def signal &b
  @sig||=GLib::Object::QGSignal.new self
  o = @sig.methods
  class << sig
    self
  end.class_eval &b
  n = @sig.methods
  s=n.find_all do |q| !o.index(q) end
  s.each do |q| define_method q do end; end
  @sig
end

def delegate &b
  # 
end

module Q;end
def require *o, pkg: nil
  return true if o[0] == 'Q'
  return(r=super(o[0].gsub(".rb",''))) if !pkg
  super "gtk3"
  Gtk::Window
  def Gtk.init *o;end
  return true
end

def sig *o,&b
end

def property *o,&b;end

def dele *o,&b;end

def defn *o,&b; end
def generics *o; end
$ns = []
def namespace m;
  $ns << m
  m
end

def GenericType(c,*t)
  c
end

def ref o;o;end

class String
  alias :get :[]
  def [] i=nil
    get i
  end
end

class Symbol
  alias :get :[]
  def [] i=nil
    get i if i
  end
end


class Module
  def self.extended *o
    p r = super;
  rescue
    return o[0]
  end
end

Q_ARGV = [File.basename($0),ARGV].flatten

at_exit {

  if n=$ns.find do |q| q.respond_to?(:main) end
    n.main(ARGV)
  end
}

