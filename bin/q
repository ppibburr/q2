#!/usr/bin/ruby -ws
$t=Time.now
$: << File.join(File.dirname(__FILE__), "/../lib")
require 'rubygems'
require 'ruby2vala'
require 'ruby_parser'

$h ||= false
$s ||= false
$first = ARGV.index('-f')
if $h then
  puts "usage: #{File.basename $0} [options] [file...]"
  puts "options:"
  puts "-h     : display usage"
  puts "-s     : print the sexp before displaying the translated ruby"

  exit 1
end
$run = ARGV.delete("-r")
$shared = ARGV.delete("--lib")
$shared ||= $gir = ARGV.delete("--gir")
$pkg = []
while i=ARGV.index("--pkg")
  ARGV.delete_at(i)
  $pkg << ARGV.delete_at(i)
end

ARGV.push "-" if ARGV.empty?

$parser = parser    = RubyParser.new
ruby2ruby = Ruby2Ruby.new
$delete = []
$scope = [Scope.new]
$sa = sa={}
$ruby = []
$one=nil
$req = {}

def output
  $sao.map do|f| "// File: #{f}\n\n"+$req[f] end.join("\n\n\n")
end

def write
  `mkdir -p ./q_generated/#{$prg}`
  $sao.map do|f| 
    out = File.join("./q_generated", $prg, File.basename(f)+".vala")
    File.open(out,"w") do |o| o.puts "// File: #{f}\n\n"+$req[f] end
    out
  end
end

def compile f, prg=$prg
  pkg = '' #if !$pkg or $pkg.empty?
  
  unless !$pkg || $pkg.empty?
    pkg << " --pkg "
    pkg << $pkg.join(" --pkg ")
  end
  
  lib=prg
  lib = prg.split("_").map do |q| q.capitalize end.join() if $gir
  l = ""
  l = " --library=#{lib} -H #{prg}.h -X -fPIC -X -shared" if $shared
  l << " --gir #{lib}-0.1.gir" if $gir
  prg = prg+".so" if $shared
  puts c="valac#{l} #{f.join(" ")}#{pkg} -o #{prg}"
  system c
end

def run prg=$prg
  system "./#{prg}"
end

$sao=[]
ARGV.each do |file|
  $pdir ||= File.dirname(file)
  $prg ||= File.basename(file).split(".")[0]
  $sao << f_path(file)
  sexp = q_require file

  p sexp if $s

  $req[file] = $one=ruby2ruby.process(sexp)
  puts output if $first
end

$req = {}

## One pass transpilation, requires more strict typing
# puts $one;exit

File.open("./types.rbm", "w") do |f|
  f.puts Marshal.dump($scope[0])
end

  begin
    $scope = [Marshal.load(open('./types.rbm').read)]
  rescue
    raise "hell"
  end

$SIG=nil
$KLASS=nil
$FE=nil
$return=nil

a=$ruby
$ruby = []
i=-1
#$two = true
sa.each do |f,sexp|
  $ruby << a[i+1]

  $req[sexp.file] = o=ruby2ruby.process(sexp)
  puts out="namespace Q { public double tt = #{Time.now-$t};}\n\n"+output if $two
  
  ## Two pass compilation more inference
  ## return types, full type assignment to vars, argument types from usage, more fields values
  exit if $two
end
$req = {}
File.open("./types.rbm", "w") do |f|
  f.puts Marshal.dump($scope[0])
end

  begin
    $scope = [Marshal.load(open('./types.rbm').read)]
  rescue
    raise "hell"
  end

$SIG=nil
$KLASS=nil
$FE=nil
$return=nil


$ruby = []
i=-1
$sao.each do |f|
  sexp = $sa[f]
  $ruby << a[i+1]
  
  $req[sexp.file] = ruby2ruby.process(sexp)
  
  ##  Three passes: much infer
  ##  return type, full type var assigment, return of type infered from argument, most field values
end

$req["./q.q"] = "namespace Q { public double tt = #{Time.now-$t};}\n\n"
$sao.unshift "./q.q"
puts output

compile write
run if $run && !$hared
